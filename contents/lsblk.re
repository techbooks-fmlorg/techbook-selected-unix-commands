#@# 

=={lsblk} @<term>{lsblk}

利用できる@<idx>{ブロックデバイス((ぶろっくでばいす))<<>>をツリー状に一覧表示する((をつりーじょうにいちらんひょうじする))}。

//note[blk][ブロックデバイス]{
ブロックデバイスとは、
512バイトなどのまとまったデータ量(ブロック)を単位として読み書きするHDDやSSDなどの記憶装置のこと。
//}

=== 書式

//list[][][fontsize=xx-small]{
$ lsblk
$ lsblk [options] [device...]
//}

 * 引数がない場合、全ブロックデバイスの情報を表示する
 * 引数で特定のデバイスを指定することも出来る

=== 実行例

==== 実行例

//list[][][fontsize=xx-small]{
$ lsblk
//}

==== 実行結果

#@# X-TODO 左端の特殊記号のせいでコンパイルすると、ずれるらしい (PENDING)
#@#        スペースで微調整して少しマシにしたけれど、根本的な解決方法は不明
//list[][][fontsize=xx-small]{
NAME      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
xvda      202:0    0    8G  0 disk 
├─xvda1  202:1    0  7.9G  0 part /
├─xvda14 202:14   0    3M  0 part 
└─xvda15 202:15   0  124M  0 part /boot/efi
//}
実用上は、左端のデバイス名と右端のマウントポイントだけ見ていれば十分だろう。
詳細は@<table>{lsblk}を参照

#@# X-TODO lsblkの表の内容をチェック
#@# X-TODO lsblkの表の位置調整
//table[lsblk][lsblkの表示]{
1行目		説明
----------------------------------------
NAME		デバイス名（OSが自動的に割り当てている）
MAJ:MIN		MAJ（メジャー）はデバイスドライバの番号
　		MIN（マイナー）は同一ドライバを使用するデバイスを区別する番号
　		(ここに表示されているxvdaはすべて同一ドライバを使用している)
RM		OS動作中に取り外し可能かどうかを示している。可能であれば1である。
SIZE		デバイスの容量
RO		読み取り専用かどうかを示している。読み取り専用であれば1である。
TYPE		デバイスのタイプを示している。diskであれば物理ディスク、
　		partであればパーティション(ディスクを論理分割したもの)を示している。
MOUNTPOINTS	デバイスにファイルシステムがマウントされていればそのパスが表示される
　		(表示されているファイルシステムでデバイスにアクセスできる)。
//}
